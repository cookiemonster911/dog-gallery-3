const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./client.ybO3B45v.js","./session.nhK5e6A4.js","./scheduler.r5UgEgUv.js","./control.CYgJF_JY.js"])))=>i.map(i=>d[i]);
var Ye=Object.defineProperty;var Ve=r=>{throw TypeError(r)};var Xe=(r,e,t)=>e in r?Ye(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var y=(r,e,t)=>Xe(r,typeof e!="symbol"?e+"":e,t),ke=(r,e,t)=>e.has(r)||Ve("Cannot "+t);var b=(r,e,t)=>(ke(r,e,"read from private field"),t?t.call(r):e.get(r)),T=(r,e,t)=>e.has(r)?Ve("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),I=(r,e,t,s)=>(ke(r,e,"write to private field"),s?s.call(r,t):e.set(r,t),t),R=(r,e,t)=>(ke(r,e,"access private method"),t);var je=(r,e,t,s)=>({set _(i){I(r,e,i,t)},get _(){return b(r,e,s)}});import{i as Fe}from"./scheduler.r5UgEgUv.js";import{g as $e,c as Ze,i as Ue}from"./session.nhK5e6A4.js";import{_ as et}from"./preload-helper.D6kgxu3v.js";const tt={watchSchema:{url:"https://api-us-east-1-shared-usea1-02.hygraph.com/v2/clz2n75bk008j07uwx0xt97ft/master"},plugins:{"houdini-svelte":{}},scalars:{RichTextAST:{type:"RichTextAST"}}},st=[];var it=st;function Ae(r){return{defaultKeys:["id"],...r,types:{Node:{keys:["id"],resolve:{queryField:"node",arguments:e=>({id:e.id})}},...r.types}}}function Be(r,e){var s,i;const t=Ae(r);return((i=(s=t.types)==null?void 0:s[e])==null?void 0:i.keys)||t.defaultKeys}function nt(r,e,t){const s=Be(r,e);let i="";for(const n of s)i+=t[n]+"__";return i.slice(0,-2)}let ve=null;function Pt(r){var e;return((e=r.router)==null?void 0:e.apiEndpoint)??"/_api"}function we(){if(ve)return ve;let r=Ae(tt);for(const e of it)r=e(r);return ve=r,r}function Ke(r){const e=[...r.matchAll(/\$HOUDINI\$(\w*\$)?/g)];if(e.length===0)return[r];let t=r.replaceAll(/\$HOUDINI\$(\w*\$)?/g,"%c"),s=[];for(const i of e){const n=i[1]?`color:${i[1].slice(0,-1)}`:"";s.push(n)}return[t,...s]}function rt(r){console.error(...Ke(r))}function at(r){console.log(...Ke(r))}const x={CacheOrNetwork:"CacheOrNetwork",CacheOnly:"CacheOnly",NetworkOnly:"NetworkOnly",CacheAndNetwork:"CacheAndNetwork",NoCache:"NoCache"},re={Query:"HoudiniQuery",Subscription:"HoudiniSubscription",Mutation:"HoudiniMutation",Fragment:"HoudiniFragment"},lt=re.Query,Se={Cache:"cache",Network:"network",Ssr:"ssr"},Ee=" $fragments",ot=Symbol("houdini_loading");let ne=null;async function We(){return ne||(ne=(await et(async()=>{const{default:r}=await import("./client.ybO3B45v.js");return{default:r}},__vite__mapDeps([0,1,2,3]),import.meta.url)).default,ne)}function Pe(){if(!ne)throw new Error("client hasn't been initialized");return ne}function me(r,e,t=new WeakMap){if(Object.is(r,e))return!0;if(r instanceof Date&&e instanceof Date)return r.getTime()===e.getTime();if(r instanceof RegExp&&e instanceof RegExp)return r.toString()===e.toString();if(typeof r!="object"||r===null||typeof e!="object"||e===null)return!1;if(t.get(r)===e)return!0;t.set(r,e);const s=Reflect.ownKeys(r),i=Reflect.ownKeys(e);if(s.length!==i.length)return!1;for(let n=0;n<s.length;n++)if(!Reflect.has(e,s[n])||!me(r[s[n]],e[s[n]],t))return!1;return!0}function K(r,e,t){if(t)return r.loadingTypes&&r.loadingTypes.length>0?Qe(...r.loadingTypes.map(i=>{var n;return(n=r.abstractFields)==null?void 0:n.fields[i]})):r.fields??{};let s=r.fields||{};if(r.abstractFields&&e){const i=r.abstractFields.typeMap[e];i?s=r.abstractFields.fields[i]:r.abstractFields.fields[e]&&(s=r.abstractFields.fields[e])}return s}function Qe(...r){const e={};for(let t of r)if(t){for(let s in t)if(s in t){const i=t[s];typeof i=="object"&&i!==null&&!Array.isArray(i)?e[s]=Qe(e[s]||{},i):e[s]=i}}return e}function Ne({selection:r,data:e}){const t=we();if(e===null||typeof e>"u")return e;if(Array.isArray(e))return e.map(i=>Ne({selection:r,data:i}));const s=K(r,e.__typename,!1);return Object.fromEntries(Object.entries(e).map(([i,n])=>{var c;if(i===Ee)return[i,n];const{type:a,selection:l}=s[i];if(!a)return[i,n];if(l)return[i,Ne({selection:l,data:n})];if((c=t.scalars)!=null&&c[a]){const o=t.scalars[a].marshal;if(!o)throw new Error(`Scalar type ${a} is missing a \`marshal\` function. See https://houdinigraphql.com/api/config#custom-scalars for help on configuring custom scalars.`);return Array.isArray(n)?[i,n.map(o)]:[i,o(n)]}return[i,n]}))}function Oe({artifact:r,input:e,config:t,rootType:s="@root"}){if(e===null||typeof e>"u"||!r.input)return e;const i=s==="@root"?r.input.fields:r.input.types[s];return Array.isArray(e)?e.map(n=>Oe({artifact:r,input:n,rootType:s,config:t})):Object.fromEntries(Object.entries(e).map(([n,a])=>{var o,f;const l=i==null?void 0:i[n];if(!l)return[n,a];const c=(f=(o=t.scalars)==null?void 0:o[l])==null?void 0:f.marshal;return c?Array.isArray(a)?[n,a.map(c)]:[n,c(a)]:ct(t,l)||!r.input.types[l]?[n,a]:[n,Oe({artifact:r,input:a,rootType:l,config:t})]}))}function ct(r,e){return["String","Boolean","Float","ID","Int"].concat(Object.keys(r.scalars||{})).includes(e)}function Nt(r,e,t){if(!(typeof t>"u"))return t}const ie=[],De=()=>{};var N,W,de;class ft{constructor(e,t=De){y(this,"state");T(this,N);T(this,W);T(this,de);this.state=e,I(this,N,new Set),I(this,W,null),I(this,de,t)}set(e){if(ut(this.state,e)&&(this.state=e,b(this,W))){const t=!ie.length;for(const s of b(this,N))s[1](),ie.push(s,this.state);if(t){for(let s=0;s<ie.length;s+=2)ie[s][0](ie[s+1]);ie.length=0}}}update(e){this.set(e(this.state))}subscribe(e,t=De){const s=[e,t];return b(this,N).add(s),b(this,N).size===1&&I(this,W,b(this,de).call(this,this.set)||De),e(this.state),()=>{var i;b(this,N).delete(s),b(this,N).size===0&&((i=b(this,W))==null||i.call(this),I(this,W,null))}}}N=new WeakMap,W=new WeakMap,de=new WeakMap;function ut(r,e){return r!=r?e==e:r!==e||r&&typeof r=="object"||typeof r=="function"}const He=({field:r,args:e})=>{const t=Object.keys(e??{});return t.sort(),e&&t.length>0?`${r}(${t.map(s=>`${s}: ${Te(e[s])}`).join(", ")})`:r},Te=r=>Array.isArray(r)?`[${r.map(e=>`${Te(e)}`).join(", ")}]`:typeof r!="object"||r instanceof Date||r===null?JSON.stringify(r).replace(/"([^"]+)":/g,"$1: "):`{${Object.keys(r).map(e=>`${e}: ${Te(r[e])}`).join(", ")}}`;function q(r){return r?r.reduce((e,t)=>t?Array.isArray(t)?e.concat(q(t)):e.concat(t):e,[]):[]}class ht{constructor(e){y(this,"cache");y(this,"lifetimes",new Map);this.cache=e}get cacheBufferSize(){return this.cache._internal_unstable.config.cacheBufferSize??10}reset(){this.lifetimes.clear()}resetLifetime(e,t){this.lifetimes.get(e)||this.lifetimes.set(e,new Map),this.lifetimes.get(e).set(t,0)}tick(){const e=Date.now().valueOf(),t=this.cache._internal_unstable.config.defaultLifetime;for(const[s,i]of this.lifetimes.entries())for(const[n,a]of i.entries())if(!(this.cache._internal_unstable.subscriptions.get(s,n).length>0)&&(i.set(n,a+1),i.get(n)>this.cacheBufferSize&&(this.cache._internal_unstable.storage.deleteField(s,n),this.cache._internal_unstable.lists.deleteField(s,n),i.delete(n),[...i.keys()].length===0&&this.lifetimes.delete(s),this.cache._internal_unstable.staleManager.delete(s,n)),t&&t>0)){const l=this.cache.getFieldTime(s,n);l&&e-l>t&&this.cache._internal_unstable.staleManager.markFieldStale(s,n)}}}class dt{constructor(e,t){y(this,"rootID");y(this,"cache");y(this,"lists",new Map);y(this,"listsByField",new Map);this.rootID=t,this.cache=e}get(e,t,s){var c;const i=this.lists.get(e);if(!i||i.size===0)return null;if(s)return new _e(Array.from(i,([o,f])=>[...f.lists]).flat());const n=[...i.values()][0],{recordType:a}=n.lists[0],l=t?this.cache._internal_unstable.id(a||"",t):this.rootID;return(i==null?void 0:i.size)===1?t?l===Array.from(i.keys())[0]?n:null:n:t?(c=this.lists.get(e))==null?void 0:c.get(l):(console.error(`Found multiple instances of "${e}". Please provide one of @parentID or @allLists directives to help identify which list you want modify. For more information, visit this guide: https://www.houdinigraphql.com/api/graphql#parentidvalue-string `),null)}remove(e,t){var s;(s=this.lists.get(e))==null||s.delete(t||this.rootID)}add(e){var n,a,l;this.lists.has(e.name)||this.lists.set(e.name,new Map);const t=e.name,s=e.recordID||this.rootID;if((a=(n=this.lists.get(t))==null?void 0:n.get(s))!=null&&a.includes(e.key))return;this.lists.has(t)||this.lists.set(t,new Map),this.lists.get(t).has(s)||this.lists.get(t).set(s,new _e([])),this.listsByField.has(s)||this.listsByField.set(s,new Map),this.listsByField.get(s).has(e.key)||(l=this.listsByField.get(s))==null||l.set(e.key,[]);const i=new pt({...e,manager:this});this.lists.get(e.name).get(s).lists.push(i),this.listsByField.get(s).get(e.key).push(i)}removeIDFromAllLists(e,t){for(const s of this.lists.values())for(const i of s.values())i.removeID(e,void 0,t)}deleteField(e,t){var s,i,n,a,l,c;if((s=this.listsByField.get(e))!=null&&s.has(t)){for(const o of this.listsByField.get(e).get(t))(n=(i=this.lists.get(o.name))==null?void 0:i.get(o.recordID))==null||n.deleteListWithKey(t),((l=(a=this.lists.get(o.name))==null?void 0:a.get(o.recordID))==null?void 0:l.lists.length)===0&&((c=this.lists.get(o.name))==null||c.delete(o.recordID));this.listsByField.get(e).delete(t)}}reset(){this.lists.clear(),this.listsByField.clear()}}class pt{constructor({name:e,recordID:t,recordType:s,key:i,listType:n,selection:a,when:l,filters:c,connection:o,manager:f,abstract:d}){y(this,"recordID");y(this,"recordType");y(this,"key");y(this,"type");y(this,"cache");y(this,"selection");y(this,"_when");y(this,"filters");y(this,"name");y(this,"connection");y(this,"manager");y(this,"abstract");this.recordID=t||B,this.recordType=s,this.key=i,this.type=n,this.cache=f.cache,this.selection=a,this._when=l,this.filters=c,this.name=e,this.connection=o,this.manager=f,this.abstract=d}when(e){return this.manager.lists.get(this.name).get(this.recordID).when(e)}append({selection:e,data:t,variables:s={},layer:i}){return this.addToList(e,t,s,"last",i)}prepend({selection:e,data:t,variables:s={},layer:i}){return this.addToList(e,t,s,"first",i)}addToList(e,t,s={},i,n){const a=this.listType(t),l=this.cache._internal_unstable.id(a,t);if(!this.validateWhen()||!l)return;let c=e,o=t;this.connection?(c={fields:{newEntry:{keyRaw:this.key,type:"Connection",selection:{fields:{edges:{keyRaw:"edges",type:"ConnectionEdge",updates:["append","prepend"],selection:{fields:{__typename:{keyRaw:"__typename",type:"String"},node:{type:a,keyRaw:"node",selection:{...e,fields:{...e.fields,__typename:{keyRaw:"__typename",type:"String"}}}}}}}}}}}},o={newEntry:{edges:[{__typename:a+"Edge",node:{...t,__typename:a}}]}}):(c={fields:{newEntries:{keyRaw:this.key,type:a,updates:["append","prepend"],selection:{...e,fields:{...e.fields,__typename:{keyRaw:"__typename",type:"String"}}}}}},o={newEntries:[{...t,__typename:a}]}),this.cache.write({selection:c,data:o,variables:s,parent:this.recordID,applyUpdates:[i==="first"?"prepend":"append"],layer:n==null?void 0:n.id})}removeID(e,t={},s){var o;if(!this.validateWhen())return;let i=this.recordID,n=e,a=this.key;if(this.connection){const{value:f}=this.cache._internal_unstable.storage.get(this.recordID,this.key);if(!f)return;const d=f,{value:u}=this.cache._internal_unstable.storage.get(d,"edges");for(const g of q(u)||[]){if(!g)continue;const m=g,{value:h}=this.cache._internal_unstable.storage.get(m,"node");h&&h===e&&(n=m)}i=d,a="edges"}let l=this.cache._internal_unstable.storage.get(i,a).value;if(!l||!l.includes(n))return;const c=this.cache._internal_unstable.subscriptions.get(this.recordID,this.key);this.cache._internal_unstable.subscriptions.remove(n,this.connection?this.selection.fields.edges.selection:this.selection,c.map(f=>f[0]),t),this.cache._internal_unstable.storage.remove(i,a,n,s);for(const[f]of c)f.set(this.cache._internal_unstable.getSelection({parent:f.parentID||this.manager.rootID,selection:f.selection,variables:((o=f.variables)==null?void 0:o.call(f))||{},ignoreMasking:!1}).data);return!0}remove(e,t={},s){const i=this.cache._internal_unstable.id(this.listType(e),e);if(i)return this.removeID(i,t,s)}listType(e){return e.__typename||this.type}validateWhen(e){let t=e||this._when,s=!0;if(t){const i=this.filters;t.must&&i&&(s=Object.entries(t.must).reduce((n,[a,l])=>!!(n&&i[a]==l),s)),t.must_not&&(s=!i||Object.entries(t.must_not).reduce((n,[a,l])=>!!(n&&i[a]!=l),s))}return s}toggleElement({selection:e,data:t,variables:s={},layer:i,where:n}){this.remove(t,s,i)||this.addToList(e,t,s,n,i)}*[Symbol.iterator](){let e=[],t=this.cache._internal_unstable.storage.get(this.recordID,this.key).value;this.connection?e=this.cache._internal_unstable.storage.get(t,"edges").value:e=q(t);for(let s of e)yield s}}class _e{constructor(e){y(this,"lists",[]);this.lists=e}get selection(){return this.lists[0].selection}append(...e){this.lists.forEach(t=>t.append(...e))}prepend(...e){this.lists.forEach(t=>t.prepend(...e))}addToList(...e){this.lists.forEach(t=>t.addToList(...e))}removeID(...e){this.lists.forEach(t=>t.removeID(...e))}remove(...e){this.lists.forEach(t=>t.remove(...e))}toggleElement(...e){this.lists.forEach(t=>t.toggleElement(...e))}when(e){return new _e(this.lists.filter(t=>t.validateWhen(e)))}includes(e){return!!this.lists.find(t=>t.key===e)}deleteListWithKey(e){return this.lists=this.lists.filter(t=>t.key!==e)}*[Symbol.iterator](){for(let e of this.lists)for(const t of e)yield t}}var pe;class gt{constructor(e){y(this,"cache");y(this,"fieldsTime",new Map);T(this,pe,e=>{this.fieldsTime.get(e)||this.fieldsTime.set(e,new Map)});this.cache=e}getFieldTime(e,t){var s;return(s=this.fieldsTime.get(e))==null?void 0:s.get(t)}setFieldTimeToNow(e,t){var s;b(this,pe).call(this,e),(s=this.fieldsTime.get(e))==null||s.set(t,new Date().valueOf())}markFieldStale(e,t){var s;b(this,pe).call(this,e),(s=this.fieldsTime.get(e))==null||s.set(t,null)}markAllStale(){for(const[e,t]of this.fieldsTime.entries())for(const[s]of t.entries())this.markFieldStale(e,s)}markRecordStale(e){const t=this.fieldsTime.get(e);if(t)for(const[s]of t.entries())this.markFieldStale(e,s)}markTypeStale(e){for(const[t,s]of this.fieldsTime.entries())if(t.startsWith(`${e}:`))for(const[i]of s.entries())this.markFieldStale(t,i)}markTypeFieldStale(e,t,s){const i=He({field:t,args:s});for(const[n,a]of this.fieldsTime.entries())if(n.startsWith(`${e}:`))for(const l of a.keys())l===i&&this.markFieldStale(n,t)}delete(e,t){var s,i;this.fieldsTime.has(e)&&((s=this.fieldsTime.get(e))==null||s.delete(t),((i=this.fieldsTime.get(e))==null?void 0:i.size)===0&&this.fieldsTime.delete(e))}reset(){this.fieldsTime.clear()}}pe=new WeakMap;class yt{constructor(){y(this,"data");y(this,"idCount",1);y(this,"rank",0);y(this,"idMaps",{});this.data=[]}get layerCount(){return this.data.length}get nextRank(){return this.rank++}registerIDMapping(e,t){this.idMaps[e]=t}createLayer(e=!1){const t=new bt(this.idCount++);return t.optimistic=e,this.data.push(t),t}insert(e,t,s,i){return this.topLayer.insert(e,t,s,i)}remove(e,t,s,i=this.topLayer){return i.remove(e,t,s)}delete(e,t=this.topLayer){return t.delete(e)}deleteField(e,t){return this.topLayer.deleteField(e,t)}getLayer(e){for(const t of this.data)if(t.id===e)return t;throw new Error("Could not find layer with id: "+e)}replaceID(e){for(const t of this.data)t.replaceID(e)}get(e,t,s){const i={[J.insert]:{[ze.start]:[],[ze.end]:[]},[J.remove]:new Set},n=[],a=[this.idMaps[e],e].filter(Boolean);for(let l=this.data.length-1;l>=0;l--)for(const c of a){const o=this.data[l];let[f,d]=o.get(c,t);const u=o.getOperations(c,t)||[];if(o.deletedIDs.forEach(g=>{var m,h;(h=(m=o.operations[g])==null?void 0:m.undoDeletesInList)!=null&&h.includes(t)||i.remove.add(g)}),typeof f>"u"&&s&&(this.topLayer.writeField(c,t,s),f=s),typeof f>"u"&&u.length===0){o.deletedIDs.size>0&&n.push(o.id);continue}if(typeof f<"u"&&!Array.isArray(f))return{value:f,kind:d,displayLayers:[o.id]};if(n.push(o.id),u.length>0){for(const g of u)if(wt(g)&&i.remove.add(g.id),_t(g)&&i.insert[g.location].unshift(g.id),mt(g))return{value:void 0,kind:"unknown",displayLayers:[]}}if(!(typeof f>"u"))return!i.remove.size&&!i.insert.start.length&&!i.insert.end.length?{value:f,displayLayers:n,kind:"link"}:{value:[...i.insert.start,...f,...i.insert.end].filter(g=>!i.remove.has(g)),displayLayers:n,kind:d}}return{value:void 0,kind:"unknown",displayLayers:[]}}writeLink(e,t,s){return this.topLayer.writeLink(e,t,s)}writeField(e,t,s){return this.topLayer.writeField(e,t,s)}resolveLayer(e){let t=null;for(const[n,a]of this.data.entries())if(a.id===e){t=n-1,this.data[n].optimistic=!1;break}if(t===null)throw new Error("could not find layer with id: "+e);t===-1&&(t=0),this.data[t].optimistic&&t++;const s=this.data[t];let i=t;for(;i<this.data.length;){const n=this.data[i++];if(n.optimistic){i--;break}s.writeLayer(n)}this.data.splice(t+1,i-t-1),this.data.length===1&&(this.idMaps={})}get topLayer(){var e;return this.data.length===0&&this.createLayer(),(e=this.data[this.data.length-1])!=null&&e.optimistic&&this.createLayer(),this.data[this.data.length-1]}serialize(){return JSON.stringify({rank:this.rank,fields:Object.fromEntries(Object.entries(this.topLayer.fields).map(([e,t])=>[e,Object.fromEntries(Object.entries(t).filter(([s,i])=>typeof i!="function"))])),links:this.topLayer.links})}hydrate(e,t){if(!e)return;const{rank:s,fields:i,links:n}=e;this.rank=s,t??(t=this.createLayer(!0)),t.fields=i,t.links=n}reset(){this.data=[]}}class bt{constructor(e){y(this,"id");y(this,"optimistic",!1);y(this,"fields",{});y(this,"links",{});y(this,"operations",{});y(this,"deletedIDs",new Set);this.id=e}get(e,t){var s,i;return typeof((s=this.links[e])==null?void 0:s[t])<"u"?[this.links[e][t],"link"]:[(i=this.fields[e])==null?void 0:i[t],"scalar"]}getOperations(e,t){var s,i,n;if((s=this.operations[e])!=null&&s.deleted)return[{kind:J.delete,target:e}];if((n=(i=this.operations[e])==null?void 0:i.fields)!=null&&n[t])return this.operations[e].fields[t]}writeField(e,t,s){return this.fields[e]={...this.fields[e],[t]:s},this.id}writeLink(e,t,s){var n,a,l;const i=Array.isArray(s)?s:[s];for(const c of q(i)){if(!c)continue;const o=(n=this.operations[e])==null?void 0:n.fields[t];(a=this.operations[c])!=null&&a.deleted||this.deletedIDs.has(c)?this.operations[c]={...this.operations[c],undoDeletesInList:[...((l=this.operations[e])==null?void 0:l.undoDeletesInList)||[],t]}:c&&(o==null?void 0:o.length)>0&&(this.operations[e].fields[t]=o.filter(f=>f.kind!=="remove"||f.id!==c))}return this.links[e]={...this.links[e],[t]:s},this.id}isDisplayLayer(e){return e.length===0||e.includes(this.id)||Math.max(...e)<this.id}clear(){this.links={},this.fields={},this.operations={},this.deletedIDs=new Set}replaceID({from:e,to:t}){this.fields[t]=this.fields[e],this.links[t]=this.links[e],this.operations[t]=this.operations[e]||{fields:{}},this.deletedIDs.has(e)&&this.deletedIDs.add(t)}removeUndefinedFields(){for(const[e,t]of Object.entries(this.fields)){for(const[s,i]of Object.entries(t))if(typeof i>"u"){try{delete this.fields[e][s]}catch{}try{delete this.links[e][s]}catch{}}Object.keys(t||{}).length===0&&delete this.fields[e],Object.keys(this.links[e]||{}).length===0&&delete this.links[e]}}delete(e){this.operations={...this.operations,[e]:{...this.operations[e],deleted:!0,undoDeletesInList:[]}},this.deletedIDs.add(e)}deleteField(e,t){this.fields[e]={...this.fields[e],[t]:void 0}}insert(e,t,s,i){this.addFieldOperation(e,t,{kind:J.insert,id:i,location:s})}remove(e,t,s){this.addFieldOperation(e,t,{kind:J.remove,id:s})}writeLayer(e){if(e.id!==this.id){for(const[t,s]of Object.entries(e.operations)){const i={};for(const n of[this.operations[t],e.operations[t]].filter(Boolean))for(const[a,l]of Object.entries(n.fields||{}))i[a]=[...i[a]||[],...l];Object.keys(i).length>0&&(this.operations[t]={...this.operations[t],fields:i}),s!=null&&s.deleted&&(delete this.fields[t],delete this.links[t])}for(const[t,s]of Object.entries(e.fields))if(s)for(const[i,n]of Object.entries(s))this.writeField(t,i,n);for(const[t,s]of Object.entries(e.links))if(s)for(const[i,n]of Object.entries(s))this.writeLink(t,i,n);e.deletedIDs.forEach(t=>this.deletedIDs.add(t))}}addFieldOperation(e,t,s){var i;this.operations={...this.operations,[e]:{...this.operations[e],fields:{[t]:[...((i=this.operations[e])==null?void 0:i.fields[t])||[],s]}}}}}function mt(r){return!!r&&r.kind===J.delete}function _t(r){return!!r&&r.kind===J.insert}function wt(r){return!!r&&r.kind===J.remove}const ze={start:"start",end:"end"},J={delete:"delete",insert:"insert",remove:"remove"};function he(r,e=null){let t="",s="",i=!1;for(const n of r){if(s){if(kt.includes(n)){s+=n;continue}const a=e==null?void 0:e[s.slice(1)];t+=typeof a<"u"?JSON.stringify(a):"undefined",s=""}if(n==="$"&&!i){s="$";continue}n==='"'&&(i=!i),t+=n}return t}const kt="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789";class vt{constructor(e){y(this,"cache");y(this,"subscribers",new Map);y(this,"keyVersions",{});this.cache=e}activeFields(e){return Object.keys(this.subscribers.get(e)||{})}add({parent:e,spec:t,selection:s,variables:i,parentType:n}){const a=this.cache._internal_unstable.storage.get(e,"__typename").value;let l=K(s,a,!1);for(const c of Object.values(l||{})){const{keyRaw:o,selection:f,type:d,list:u,filters:g,visible:m}=c;if(!m)continue;const h=he(o,i);let w;if(f){const S=this.cache._internal_unstable.storage.get(e,"__typename").value;w=K(f,S,!1)}if(this.addFieldSubscription({id:e,key:h,selection:[t,w],type:d}),u&&this.registerList({list:u,filters:g,id:e,key:h,variables:i,selection:f,parentType:n||t.rootType}),f){const{value:S}=this.cache._internal_unstable.storage.get(e,h);let _=Array.isArray(S)?q(S)||[]:[S];for(const k of _)k&&this.add({parent:k,spec:t,selection:f,variables:i,parentType:d})}}}addFieldSubscription({id:e,key:t,selection:s,type:i}){const n=s[0];this.subscribers.has(e)||this.subscribers.set(e,new Map);const a=this.subscribers.get(e);a.has(t)||a.set(t,{selections:[],referenceCounts:new Map});const l=a.get(t);this.keyVersions[t]||(this.keyVersions[t]=new Set),this.keyVersions[t].add(t),l.selections.some(([{set:c}])=>c===n.set)||l.selections.push([n,s[1]]),l.referenceCounts.set(n.set,(l.referenceCounts.get(n.set)||0)+1),this.cache._internal_unstable.lifetimes.resetLifetime(e,t)}registerList({list:e,id:t,key:s,parentType:i,selection:n,filters:a,variables:l}){var c;this.cache._internal_unstable.lists.add({name:e.name,connection:e.connection,recordID:t,recordType:((c=this.cache._internal_unstable.storage.get(t,"__typename"))==null?void 0:c.value)||i,listType:e.type,key:s,selection:n,filters:Object.entries(a||{}).reduce((o,[f,{kind:d,value:u}])=>({...o,[f]:d!=="Variable"?u:l[u]}),{})})}addMany({parent:e,variables:t,subscribers:s,parentType:i}){for(const[n,a]of s)for(const l of Object.values(a??{})){const{type:c,keyRaw:o,selection:f,list:d,filters:u}=l,g=he(o,t),m=f?K(f,i,!1):void 0;this.addFieldSubscription({id:e,key:g,selection:[n,m],type:c}),d&&this.registerList({list:d,filters:u,id:e,key:g,variables:t,selection:f,parentType:i||n.rootType});const h=l.selection;if(h){const{value:w}=this.cache._internal_unstable.storage.get(e,g),S=Array.isArray(w)?q(w):[w];for(const _ of S){if(!_)continue;const k=this.cache._internal_unstable.storage.get(_,"__typename").value;let C=K(h,k,!1);this.addMany({parent:_,variables:t,subscribers:s.map(([$])=>[$,C]),parentType:c})}}}}get(e,t){var s,i;return((i=(s=this.subscribers.get(e))==null?void 0:s.get(t))==null?void 0:i.selections)||[]}remove(e,t,s,i,n=[]){n.push(e);const a=[],l=this.cache._internal_unstable.storage.get(e,"__typename").value;let c=K(t,l,!1);for(const o of Object.values(c||{})){const f=he(o.keyRaw,i);if(this.removeSubscribers(e,f,s),!o.selection)continue;const{value:d}=this.cache._internal_unstable.storage.get(e,f),u=Array.isArray(d)?q(d):[d];for(const g of u)g!==null&&a.push([g,o.selection||{}])}for(const[o,f]of a)this.remove(o,f,s,n)}reset(){const e=[...this.subscribers.entries()].filter(([s])=>!s.startsWith(B));for(const[s,i]of e)this.subscribers.delete(s);return e.flatMap(([s,i])=>[...i.values()].flatMap(n=>n.selections.map(([a])=>a)))}removeSubscribers(e,t,s){var l;let i=[];const n=this.subscribers.get(e);if(!n)return;const a=n.get(t);for(const c of s){const o=(l=n.get(t))==null?void 0:l.referenceCounts;if(!(o!=null&&o.has(c.set)))continue;const f=(o.get(c.set)||0)-1;o.set(c.set,f),f<=0&&(i.push(c.set),o.delete(c.set)),o.size===0&&n.delete(t)}a&&(a.selections=this.get(e,t).filter(([{set:c}])=>!i.includes(c))),n.size===0&&this.subscribers.delete(e)}removeAllSubscribers(e,t,s=[]){s.push(e);const i=this.subscribers.get(e);for(const[n,a]of(i==null?void 0:i.entries())??[]){const l=t||a.selections.map(([d])=>d);this.removeSubscribers(e,n,l);const{value:c,kind:o}=this.cache._internal_unstable.storage.get(e,n);if(o==="scalar")continue;const f=Array.isArray(c)?q(c):[c];for(const d of f)s.includes(d)||this.removeAllSubscribers(d,l,s)}}get size(){let e=0;for(const[,t]of this.subscribers)for(const[,{referenceCounts:s}]of t)e+=[...s.values()].reduce((i,n)=>i+n,0);return e}}var St={},ae,ye;class xe{constructor({disabled:e,componentCache:t,createComponent:s,...i}={}){T(this,ae);y(this,"_internal_unstable");this._internal_unstable=new Dt({cache:this,storage:new yt,subscriptions:new vt(this),lists:new dt(this,B),lifetimes:new ht(this),staleManager:new gt(this),disabled:e??typeof globalThis.window>"u",componentCache:t,createComponent:s}),Object.keys(i).length>0&&this.setConfig(Ae(i))}write({layer:e,notifySubscribers:t=[],...s}){const i=e?this._internal_unstable.storage.getLayer(e):this._internal_unstable.storage.topLayer,n=this._internal_unstable.writeSelection({...s,layer:i}).map(a=>a[0]);return R(this,ae,ye).call(this,n.concat(t)),n}read(...e){const{data:t,partial:s,stale:i,hasData:n}=this._internal_unstable.getSelection(...e);return n?{data:t,partial:s,stale:i}:{data:null,partial:!1,stale:!1}}subscribe(e,t={}){if(!this._internal_unstable.disabled)return this._internal_unstable.subscriptions.add({parent:e.parentID||B,spec:e,selection:e.selection,variables:t})}unsubscribe(e,t={}){return this._internal_unstable.subscriptions.remove(e.parentID||B,e.selection,[e],t)}list(e,t,s){const i=this._internal_unstable.lists.get(e,t,s);if(!i)throw new Error(`Cannot find list with name: ${e}${t?" under parent "+t:""}. Is it possible that the query is not mounted?`);return i}registerKeyMap(e,t){this._internal_unstable.storage.registerIDMapping(e,t)}delete(e,t){this._internal_unstable.subscriptions.removeAllSubscribers(e),this._internal_unstable.lists.removeIDFromAllLists(e,t),this._internal_unstable.storage.delete(e,t)}setConfig(e){this._internal_unstable.setConfig(e)}markTypeStale(e){e?e.field?this._internal_unstable.staleManager.markTypeFieldStale(e.type,e.field,e.when):this._internal_unstable.staleManager.markTypeStale(e.type):this._internal_unstable.staleManager.markAllStale()}markRecordStale(e,t){if(t.field){const s=He({field:t.field,args:t.when??{}});this._internal_unstable.staleManager.markFieldStale(e,s)}else this._internal_unstable.staleManager.markRecordStale(e)}getFieldTime(e,t){return this._internal_unstable.staleManager.getFieldTime(e,t)}config(){return this._internal_unstable.config}serialize(){return this._internal_unstable.storage.serialize()}hydrate(...e){return this._internal_unstable.storage.hydrate(...e)}clearLayer(e){const t=this._internal_unstable.storage.getLayer(e);if(!t)throw new Error("Cannot find layer with id: "+e);const s=[],i=[];for(const a of[t.fields,t.links])for(const[l,c]of Object.entries(a))i.push(...Object.entries(c).map(([o,f])=>({id:l,field:o,value:f})));const n=[];for(const a of i){const{displayLayers:l}=this._internal_unstable.storage.get(a.id,a.field);l.includes(e)&&n.push(a)}for(const[a,l]of Object.entries(t.operations)){l.deleted&&n.push(...this._internal_unstable.subscriptions.activeFields(a).map(o=>({id:a,field:o})));const c=Object.keys(l.fields??{});c.length>0&&n.push(...c.map(o=>({id:a,field:o})))}t.clear();for(const a of n){const{field:l,id:c}=a;(!("value"in a)||this._internal_unstable.storage.get(c,l).value!==a.value)&&s.push(...this._internal_unstable.subscriptions.get(c,l).map(f=>f[0]))}R(this,ae,ye).call(this,s)}reset(){const e=this._internal_unstable.subscriptions.reset();this._internal_unstable.staleManager.reset(),this._internal_unstable.lifetimes.reset(),this._internal_unstable.lists.reset(),this._internal_unstable.storage.reset(),R(this,ae,ye).call(this,e)}}ae=new WeakSet,ye=function(e){var s;if(e.length===0)return;const t=[];for(const i of e)t.includes(i.set)||(t.push(i.set),i.set(this._internal_unstable.getSelection({parent:i.parentID||B,selection:i.selection,variables:((s=i.variables)==null?void 0:s.call(i))||{},ignoreMasking:!1}).data))};class Dt{constructor({storage:e,subscriptions:t,lists:s,cache:i,lifetimes:n,staleManager:a,disabled:l,config:c,componentCache:o,createComponent:f}){y(this,"disabled",!1);y(this,"_config");y(this,"storage");y(this,"subscriptions");y(this,"lists");y(this,"cache");y(this,"lifetimes");y(this,"staleManager");y(this,"componentCache");y(this,"createComponent");this.storage=e,this.subscriptions=t,this.lists=s,this.cache=i,this.lifetimes=n,this.staleManager=a,this._config=c,this.componentCache=o??{},this.createComponent=f??(()=>({})),this.disabled=l;try{St.HOUDINI_TEST==="true"&&(this.disabled=!1)}catch{}}get config(){return this._config??we()}setConfig(e){this._config=e}writeSelection({data:e,selection:t,variables:s={},parent:i=B,applyUpdates:n,layer:a,toNotify:l=[],forceNotify:c,forceStale:o}){if(this.disabled)return[];let f=K(t,e.__typename,!1);for(const[d,u]of Object.entries(e)){if(!t||!f[d])continue;let{type:g,keyRaw:m,selection:h,operations:w,abstract:S,updates:_}=f[d];const k=he(m,s);u&&typeof u=="object"&&"__typename"in u&&u.__typename&&(g=u.__typename);const C=this.subscriptions.get(i,k),$=C.map(p=>p[0]),{value:O,displayLayers:fe}=this.storage.get(i,k),se=a.isDisplayLayer(fe);if(se&&(this.lifetimes.resetLifetime(i,k),o?this.staleManager.markFieldStale(i,k):this.staleManager.setFieldTimeToNow(i,k)),h){if(u===null){if(O===null)continue;const p=q([O]);for(const D of p)this.subscriptions.remove(D,h,$,s);a.writeLink(i,k,null),l.push(...C)}else if(u instanceof Object&&!Array.isArray(u)){if(S&&!u.__typename)throw new Error("Encountered interface type without __typename in the payload");let p=null;u!==null&&(p=this.isEmbedded(g,u)?`${i}.${k}`:this.id(g,u));let D=p!==O;a.writeLink(i,k,p),p&&se&&(D||c)&&(O&&typeof O=="string"&&this.subscriptions.remove(O,h,$,s),this.subscriptions.addMany({parent:p,subscribers:C,variables:s,parentType:g}),l.push(...C)),p&&this.writeSelection({selection:h,parent:p,data:u,variables:s,toNotify:l,applyUpdates:n,layer:a,forceNotify:c})}else if(Array.isArray(u)&&(typeof O>"u"||O===null||Array.isArray(O))){let p=[...O||[]];const D=_?p.map(v=>{if(!v)return"";const{value:M}=this.storage.get(v,"cursor");if(M)return"";const{value:V}=this.storage.get(v,"node");return V||""}):[];let E=[];const{newIDs:F,nestedIDs:G}=this.extractNestedListIDs({value:u,abstract:!!S,specs:l,applyUpdates:n,recordID:i,key:k,linkedType:g,variables:s,fields:h,layer:a,forceNotify:c});if(n&&_){if(k==="edges"){const v=[];for(const M of F){if(!M)continue;const{value:V}=this.storage.get(M,"node");typeof V=="string"&&(!V||!this.storage.get(V,"__typename")||v.push(V))}p=p.filter(M=>{if(!M)return!0;const{value:V}=this.storage.get(M,"node"),A=V;return!(v.includes(A)&&D.includes(A))})}for(const v of n)v!=="replace"&&!_.includes(v)||(v==="prepend"?E=F.concat(p):v==="append"?E=p.concat(F):v==="replace"&&(E=F))}else E=G;const ue=!me(E,p)||O===null;(ue||c)&&l.push(...C);for(const v of p)E.includes(v)||!v||this.subscriptions.remove(v,h,$,s);(ue||p.length===0&&F.length===0)&&a.writeLink(i,k,E);for(const v of F.filter(M=>!p.includes(M)))v!=null&&this.subscriptions.addMany({parent:v,subscribers:C,variables:s,parentType:g})}}else{let p=u;if(_&&n&&Array.isArray(u))for(const E of n)_.includes(E)&&(E==="append"?p=(O||[]).concat(u):E==="prepend"&&(p=u.concat(O||[])));(_&&(n!=null&&n.includes("prepend"))&&["endCursor","hasNextPage"].includes(k)||_&&(n!=null&&n.includes("append"))&&["startCursor","hasPreviousPage"].includes(k))&&(p=O);const D=!me(p,O);se&&(D||c)&&l.push(...C),a.writeField(i,k,p)}for(const p of w||[]){let D;if(p.parentID)if(p.parentID.kind!=="Variable")D=p.parentID.value;else{const F=s[p.parentID.value];if(typeof F!="string")throw new Error("parentID value must be a string");D=F}if(p.list&&!this.lists.get(p.list,D,p.target==="all"))continue;const E=Array.isArray(u)?u:[u];for(const F of E)if(p.action==="insert"&&F instanceof Object&&h&&p.list)this.cache.list(p.list,D,p.target==="all").when(p.when).addToList(h,F,s,p.position||"last",a);else if(p.action==="toggle"&&F instanceof Object&&h&&p.list)this.cache.list(p.list,D,p.target==="all").when(p.when).toggleElement({selection:h,data:F,variables:s,where:p.position||"last",layer:a});else if(p.action==="remove"&&F instanceof Object&&h&&p.list)this.cache.list(p.list,D,p.target==="all").when(p.when).remove(F,s,a);else if(p.action==="delete"&&p.type&&F){const G=this.id(p.type,F);if(!G)continue;this.cache.delete(G,a)}}}return l}getSelection({selection:e,parent:t=B,variables:s,stepsFromConnection:i=null,ignoreMasking:n,fullCheck:a=!1,loading:l}){var h,w,S;if(t===null)return{data:null,partial:!1,stale:!1,hasData:!0};const c={};e.fragments&&(c[Ee]={loading:!!l,values:Object.fromEntries(Object.entries(e.fragments).filter(([,_])=>!l||_.loading).map(([_,k])=>[_,{parent:t,variables:be(k.arguments,s??{})}]))});let o=!!e.fragments,f=!1,d=!1,u=!1;const g=this.storage.get(t,"__typename").value;let m=K(e,g,!!l);for(const[_,{type:k,keyRaw:C,selection:$,nullable:O,list:fe,visible:se,directives:p,loading:D,abstractHasRequired:E,component:F}]of Object.entries(m)){if(!se&&!n&&!a)continue;const G=p==null?void 0:p.find(L=>L.name==="include");if(G&&!be(G.arguments,s??{}).if)continue;const ue=p==null?void 0:p.find(L=>L.name==="skip");if(ue&&be(ue.arguments,s??{}).if)continue;const v=se||n?c:{},M=he(C,s);if(l&&!D)continue;const V=F?It({cache:this.cache,component:F,variables:s,parent:t}):void 0;let{value:A}=this.storage.get(t,M,V);this.staleManager.getFieldTime(t,M)===null&&(u=!0),l&&(A=void 0);let Y=i;Y!==null&&(Y>=2?Y=null:Y+=1),fe!=null&&fe.connection&&(Y=0);const Re=M==="cursor"&&i===1;if(typeof A>"u"&&!Re&&(f=!0),l&&(D==null?void 0:D.kind)==="value")v[_]=ot,o=!0;else if(!l&&typeof A>"u"||A===null)v[_]=null,typeof A<"u"&&(o=!0);else if($)if(Array.isArray(A)){const L=this.hydrateNestedList({fields:$,variables:s,linkedList:A,stepsFromConnection:Y,ignoreMasking:!!n,fullCheck:a,loading:l,nullable:!!O});v[_]=L.data,L.partial&&(f=!0),L.cascadeNull&&(d=!0),L.stale&&(u=!0),(L.hasData||A.length===0)&&(o=!0)}else{const L=this.getSelection({parent:A,selection:$,variables:s,stepsFromConnection:Y,ignoreMasking:n,fullCheck:a,loading:l});v[_]=L.data,L.partial&&(f=!0),L.stale&&(u=!0),L.hasData&&(o=!0)}else{const L=(S=(w=(h=this.config)==null?void 0:h.scalars)==null?void 0:w[k])==null?void 0:S.unmarshal;L?Array.isArray(A)?v[_]=A.map(Ge=>L(Ge)):v[_]=L(A):v[_]=A,o=!0}l&&(D!=null&&D.list)&&(v[_]=Je(Array.from({length:D.list.count}).fill(v[_]),D.list.depth-1)),v[_]===null&&!O&&!Re&&(E?c[_]={__typename:"@required field missing; don't match this"}:d=!0)}return{data:d?null:c,partial:!l&&o&&f,stale:o&&u,hasData:o}}id(e,t){const s=typeof t=="object"?this.computeID(e,t):t;return s?e?e+":"+s:s:null}idFields(e){return Be(this.config,e)}computeID(e,t){return nt(this.config,e,t)}isEmbedded(e,t){const s=this.idFields(e);return s.length===0||s.filter(i=>typeof t[i]>"u").length>0}hydrateNestedList({fields:e,variables:t,linkedList:s,stepsFromConnection:i,ignoreMasking:n,fullCheck:a,loading:l,nullable:c}){const o=[];let f=!1,d=!1,u=!1,g=!1;for(const m of s){if(Array.isArray(m)){const k=this.hydrateNestedList({fields:e,nullable:c,variables:t,linkedList:m,stepsFromConnection:i,ignoreMasking:n,fullCheck:a,loading:l});o.push(k.data),k.partial&&(f=!0),k.cascadeNull&&(g=!0);continue}if(m===null){o.push(m);continue}const{data:h,partial:w,stale:S,hasData:_}=this.getSelection({parent:m,selection:e,variables:t,stepsFromConnection:i,ignoreMasking:n,fullCheck:a,loading:l});h===null&&!c&&(g=!0),o.push(h),w&&(f=!0),S&&(d=!0),_&&(u=!0)}return{data:o,partial:f,stale:d,hasData:u,cascadeNull:g}}extractNestedListIDs({value:e,abstract:t,recordID:s,key:i,linkedType:n,fields:a,variables:l,applyUpdates:c,specs:o,layer:f,forceNotify:d}){const u=[],g=[];for(const[m,h]of e.entries()){if(Array.isArray(h)){const C=this.extractNestedListIDs({value:h,abstract:t,recordID:s,key:i,linkedType:n,fields:a,variables:l,applyUpdates:c,specs:o,layer:f,forceNotify:d});g.push(...C.newIDs),u[m]=C.nestedIDs;continue}if(h===null||typeof h>"u"){g.push(null),u[m]=null;continue}const w=h;let S=`${s}.${i}[${this.storage.nextRank}]`,_=n;const k=w.__typename;if(k)_=k;else if(t)throw new Error("Encountered interface type without __typename in the payload");if(!this.isEmbedded(n,h)){const C=this.id(_,h);if(C)S=C;else continue}this.writeSelection({root:B,selection:a,parent:S,data:w,variables:l,toNotify:o,applyUpdates:c,layer:f,forceNotify:d}),g.push(S),u[m]=S}return{newIDs:g,nestedIDs:u}}collectGarbage(){this.lifetimes.tick(),this.storage.layerCount===1&&this.storage.topLayer.removeUndefinedFields()}}function be(r,e){return Object.fromEntries(Object.entries(r).map(([t,s])=>[t,Le(s,e)]))}function Je(r,e=0){return e===0?r:Je([r],e-1)}function Le(r,e){if(r.kind==="StringValue"||r.kind==="BooleanValue"||r.kind==="EnumValue")return r.value;if(r.kind==="FloatValue")return parseFloat(r.value);if(r.kind==="IntValue")return parseInt(r.value,10);if(r.kind==="NullValue")return null;if(r.kind==="Variable")return e[r.name.value];if(r.kind==="ListValue")return r.values.map(t=>Le(t,e));if(r.kind==="ObjectValue")return r.fields.reduce((t,s)=>({...t,[s.name.value]:Le(s.value,e)}),{})}const B="_ROOT_";function It({cache:r,component:e,loading:t,variables:s,parent:i}){return n=>{const a=r._internal_unstable.componentCache[e.key],l=be(e.variables??{},s??{});return r._internal_unstable.createComponent(a,{...n,[e.prop]:{[Ee]:{loading:t,values:{[e.fragment]:{variables:l,parent:i}}}}})}}var Ft=new xe;const Ie=typeof globalThis.window>"u",Ot=({enabled:r,setFetching:e,cache:t=Ft,serverSideFallback:s=!0})=>()=>({beforeNetwork(i,{initialValue:n,next:a,resolve:l,marshalVariables:c}){var u,g;const{policy:o,artifact:f}=i;let d=!1;if(r&&(f.kind===re.Query||f.kind===re.Fragment)&&!((u=i.cacheParams)!=null&&u.disableRead)&&o!==x.NetworkOnly&&o!==x.NoCache){const h=t.read({selection:f.selection,variables:c(i),fullCheck:!0}),w=!h.partial||f.kind===re.Query&&f.partial;if(o===x.CacheOnly)return l(i,{fetching:!1,variables:i.variables??null,data:w?h.data:n.data,errors:null,source:Se.Cache,partial:w?h.partial:!1,stale:h.stale});if(d=!!(h.data!==null&&w),d&&l(i,{fetching:!1,variables:i.variables??null,data:h.data,errors:null,source:Se.Cache,partial:h.partial,stale:h.stale}),d&&!h.partial&&!h.stale&&i.policy!=="CacheAndNetwork")return}if(r&&setTimeout(()=>{t._internal_unstable.collectGarbage()},0),!((g=i.stuff)!=null&&g.silenceLoading)){let m=null;!d&&"enableLoadingState"in f&&f.enableLoadingState&&(m=t.read({selection:f.selection,variables:c(i),loading:!0}).data),e(!d,m)}return a(i)},afterNetwork(i,{resolve:n,value:a,marshalVariables:l}){var c,o,f;if(i.policy!==x.NoCache&&a.source!==Se.Cache&&r&&a.data&&!((c=i.cacheParams)!=null&&c.disableWrite)){i.cacheParams&&"serverSideFallback"in i.cacheParams&&(s=((o=i.cacheParams)==null?void 0:o.serverSideFallback)??s);const d=Ie&&s?new xe({disabled:!1}):t;let u;!Ie&&((f=i.cacheParams)!=null&&f.layer)&&(u=i.cacheParams.layer.id),d.write({...i.cacheParams,layer:u,selection:i.artifact.selection,data:a.data,variables:l(i)}),a={...a,data:d.read({selection:i.artifact.selection,variables:l(i),ignoreMasking:Ie}).data}}n(i,a)}}),qe={forward:["start","beforeNetwork","network"],backwards:["end","afterNetwork"]};var X,ge,z,Z,le,j,P;class Tt extends ft{constructor({artifact:t,plugins:s,pipeline:i,client:n,cache:a,enableCache:l=!0,initialValue:c,initialVariables:o,fetching:f}){f??(f=t.kind===re.Query);super({data:c??null,errors:null,partial:!1,stale:!1,source:null,fetching:f,variables:o??null},()=>()=>{I(this,Z,null),this.cleanup()});T(this,j);y(this,"artifact");T(this,X);T(this,ge);T(this,z);T(this,Z);T(this,le,null);y(this,"pendingPromise",null);y(this,"serverSideFallback");this.artifact=t,I(this,X,n),I(this,Z,null),I(this,ge,we()),I(this,z,i??[Ot({cache:a,enabled:l,setFetching:(u,g)=>{this.update(m=>{const h={...m,fetching:u};return u&&g&&(h.data=g),h})}})(),...s??[]])}async send({metadata:t,session:s,fetch:i,variables:n,policy:a,stuff:l,cacheParams:c,setup:o=!1,silenceEcho:f=!1}={}){let d=new Ce({config:b(this,ge),name:this.artifact.name,text:this.artifact.raw,hash:this.artifact.hash,policy:a??this.artifact.policy,variables:null,metadata:t,session:s,fetch:i??this.getFetch(()=>s),stuff:{inputs:{changed:!1,init:!1,marshaled:{}},...l},artifact:this.artifact,lastVariables:b(this,Z),cacheParams:c});const u=d.draft();u.variables=n??null,d=d.apply(u,!1);const g=new Promise((m,h)=>{const w={setup:o,currentStep:0,index:0,silenceEcho:f,promise:{resolved:!1,resolve:m,reject:h,then:(...S)=>g.then(...S)},context:d};this.pendingPromise===null&&(this.pendingPromise=w.promise),R(this,j,P).call(this,"forward",w)});return await g}async cleanup(){var t;for(const s of b(this,z))(t=s.cleanup)==null||t.call(s,b(this,le))}getFetch(t){return async(s,i)=>{var l;let n="",a=[];if(typeof s=="string"&&(n=s.startsWith("http")?new URL(s).pathname:s),s instanceof URL?n=s.pathname:s instanceof Request&&(n=new URL(s.url).pathname),s instanceof Request){const c=await s.json();Array.isArray(c)||(a=[c])}else{const c=JSON.parse(i==null?void 0:i.body);Array.isArray(c)||(a=[c])}if(!n||a.length===0)return await globalThis.fetch(s,i);if((l=b(this,X))!=null&&l.proxies[n]){const c=await Promise.all(a.map(o=>{var f;return(f=b(this,X))==null?void 0:f.proxies[n]({...o,session:t()})}));return new Response(JSON.stringify(c.length===1?c[0]:c))}return await globalThis.fetch(s,i)}}}X=new WeakMap,ge=new WeakMap,z=new WeakMap,Z=new WeakMap,le=new WeakMap,j=new WeakSet,P=function(t,s,i){var c;const n=t==="error"?"catch":qe[t][s.currentStep];let a=o=>o<=b(this,z).length,l=o=>o+1;["backwards","error"].includes(t)&&(a=o=>o>=0,l=o=>o-1);for(let o=s.index;a(o);o=l(o)){let f=(c=b(this,z)[o])==null?void 0:c[n];if(!f)continue;const d=s.context.draft();let u=h=>h.variables!==d.variables;const g={initialValue:this.state,client:b(this,X),variablesChanged:Ct,marshalVariables:Lt,updateState:this.update.bind(this),next:h=>{const w=["forward","error"].includes(t)?o+1:o,S=["backwards","error"].includes(t)?0:s.currentStep;R(this,j,P).call(this,"forward",{...s,index:w,currentStep:S,context:s.context.apply(h,u(h))})},resolve:(h,w)=>{const S=t==="backwards"?o-1:o;R(this,j,P).call(this,"backwards",{...s,index:S,context:s.context.apply(h,u(h))},w)}};let m;t==="forward"?m=g:t==="backwards"?m={...g,value:i,resolve:(h,w)=>g.resolve(h,w??i)}:t==="error"&&(m={...g,error:i});try{const h=f(d,m);h==null||h.catch(w=>{R(this,j,P).call(this,"error",{...s,index:o-1},w)})}catch(h){R(this,j,P).call(this,"error",{...s,index:o-1},h)}return}if(t==="forward"){if(s.setup)return R(this,j,P).call(this,"backwards",{...s,currentStep:0,index:b(this,z).length},this.state);if(s.currentStep<=qe.forward.length-2)return R(this,j,P).call(this,"forward",{...s,currentStep:s.currentStep+1,index:0});throw new Error("Called next() on last possible plugin. Your chain is missing a plugin that calls resolve().")}if(t==="error"){s.promise.resolved||(s.promise.reject(i),s.promise.resolved=!0);return}if(s.currentStep>0)return R(this,j,P).call(this,"backwards",{...s,currentStep:s.currentStep-1,index:b(this,z).length-1},i);(!s.silenceEcho||i.data!==this.state.data)&&this.set(i),s.promise.resolved||(s.promise.resolve(i),s.promise.resolved=!0),I(this,le,s.context.draft()),I(this,Z,b(this,le).stuff.inputs.marshaled)};var U,oe;const Me=class Me{constructor({lastVariables:e,...t}){T(this,U);T(this,oe);I(this,U,t),I(this,oe,e)}get variables(){return b(this,U).variables}draft(){const e={...b(this,U)},t=this.applyVariables.bind(this);return{...e,get stuff(){return e.stuff},set stuff(s){e.stuff=s},get variables(){return e.variables??null},set variables(s){Object.assign(e,t(e,{variables:s}))}}}applyVariables(e,t){var o,f;const s=e.artifact,i={...e,...t},n=t.variables;let a={};for(const[d,u]of Object.entries(n??{}))u!==((o=e.variables)==null?void 0:o[d])&&(a[d]=u);i.stuff={...i.stuff,inputs:{...i.stuff.inputs}};const l=!i.stuff.inputs||!i.stuff.inputs.init;if(Object.keys(a).length>0||l){const d={...(f=i.stuff.inputs)==null?void 0:f.marshaled,...Oe({artifact:s,input:a,config:e.config})};i.stuff.inputs={init:!0,marshaled:d,changed:!0},i.variables=n}return i.stuff={...i.stuff,inputs:{...i.stuff.inputs,changed:!me(i.stuff.inputs.marshaled,b(this,oe))}},i}apply(e,t){return t&&(e=this.applyVariables(b(this,U),e)),new Me({...e,lastVariables:b(this,oe)})}};U=new WeakMap,oe=new WeakMap;let Ce=Me;function Lt(r){var e;return((e=r.stuff.inputs)==null?void 0:e.marshaled)??{}}function Ct(r){var e;return(e=r.stuff.inputs)==null?void 0:e.changed}var ee,ce,Q,te,H;class At{constructor(e){T(this,ee);T(this,ce);T(this,Q,null);T(this,te,null);T(this,H,0);typeof e.initialize>"u"&&(e.initialize=!0),I(this,ce,new Tt({artifact:e.artifact,client:null,fetching:e.fetching,initialValue:e.initialValue})),I(this,ee,e)}get artifact(){return b(this,ee).artifact}get name(){return this.artifact.name}get observer(){return b(this,te)?b(this,te):(I(this,te,Pe().observe(b(this,ee))),b(this,te))}subscribe(...e){const t=b(this,ce).subscribe(...e);return(b(this,H)===0||!b(this,Q))&&this.setup(),I(this,H,(b(this,H)??0)+1),()=>{var s;je(this,H)._--,b(this,H)<=0&&((s=b(this,Q))==null||s.call(this),I(this,Q,null),t())}}setup(e=!0){let t=Promise.resolve();try{Pe()}catch{t=We()}t.then(()=>{if(!b(this,Q)&&(I(this,Q,this.observer.subscribe(s=>{b(this,ce).set(s)})),e&&b(this,ee).initialize))return this.observer.send({setup:!0,variables:Fe(this.observer).variables})})}}ee=new WeakMap,ce=new WeakMap,Q=new WeakMap,te=new WeakMap,H=new WeakMap;class zt extends At{constructor({artifact:t,storeName:s,variables:i}){var a;const n=((a=t.pluginData["houdini-svelte"])==null?void 0:a.isManualLoad)!==!0;super({artifact:t,fetching:n,initialize:!t.pluginData["houdini-svelte"].isManualLoad});y(this,"variables");y(this,"kind",lt);y(this,"loadPending",!1);y(this,"storeName");this.storeName=s,this.variables=i}async fetch(t){var S;const s=await We();this.setup(!1);const{policy:i,params:n,context:a}=await Et(this.artifact,this.storeName,t),l=!!("event"in n&&n.event),c=!l;if(this.loadPending&&c)return rt(`⚠️ Encountered fetch from your component while ${this.storeName}.load was running.
This will result in duplicate queries. If you are trying to ensure there is always a good value, please a CachePolicy instead.`),Fe(this.observer);c&&(n.blocking=!0);const f=we().plugins["houdini-svelte"],d=this.artifact.pluginData["houdini-svelte"];let u=!1;(s.throwOnError_operations.includes("all")||s.throwOnError_operations.includes("query"))&&f.defaultRouteBlocking===!1&&at('[Houdini] ⚠️ throwOnError with operation "all" or "query", is not compatible with defaultRouteBlocking set to "false"'),f.defaultRouteBlocking===!0&&(u=!0),(s.throwOnError_operations.includes("all")||s.throwOnError_operations.includes("query"))&&(u=!0),(d==null?void 0:d.set_blocking)===!0?u=!0:(d==null?void 0:d.set_blocking)===!1&&(u=!1),(n==null?void 0:n.blocking)===!0?u=!0:(n==null?void 0:n.blocking)===!1&&(u=!1),l&&(this.loadPending=!0),this.artifact.enableLoadingState&&(u=!1);const g=Ze&&Ue&&!u,m={...(S=this.artifact.input)==null?void 0:S.defaults,...n.variables};i!==x.NetworkOnly&&i!==x.NoCache&&g&&await this.observer.send({fetch:a.fetch,variables:m,metadata:n.metadata,session:a.session,policy:x.CacheOnly,silenceEcho:!0});const w=this.observer.send({fetch:a.fetch,variables:m,metadata:n.metadata,session:a.session,policy:i,stuff:{}});return w.then(_=>{var k;this.loadPending=!1,(k=n.then)==null||k.call(n,_.data)}).catch(()=>{}),g||await w,Fe(this.observer)}}async function Et(r,e,t){let s=t==null?void 0:t.policy;!s&&r.kind===re.Query&&(s=r.policy??x.CacheOrNetwork);let i=null;t&&("fetch"in t&&t.fetch?i=t.fetch:"event"in t&&t.event&&"fetch"in t.event&&(i=t.event.fetch)),i||(i=globalThis.fetch.bind(globalThis));let n;return t&&"event"in t&&t.event?n=await $e(t.event):n=await $e(),{context:{fetch:i,metadata:(t==null?void 0:t.metadata)??{},session:n},policy:s,params:t??{}}}export{re as A,Se as D,zt as Q,K as a,tt as b,nt as c,me as d,Ft as e,q as f,we as g,Tt as h,We as i,Be as k,Pt as l,Ne as m,Nt as p};
